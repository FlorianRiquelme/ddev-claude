---
phase: 01-firewall-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - .ddev/firewall/healthcheck.sh
  - .ddev/firewall/entrypoint.sh
autonomous: true

must_haves:
  truths:
    - "Healthcheck verifies iptables rules are loaded"
    - "Healthcheck verifies ipset exists with entries"
    - "Healthcheck verifies blocking is working (test blocked connection)"
    - "Blocked requests are logged to internal file for Phase 2 whitelist suggestions"
    - "Container shows unhealthy status in `ddev status` if firewall fails"
  artifacts:
    - path: ".ddev/firewall/healthcheck.sh"
      provides: "Docker healthcheck script for firewall validation"
      contains: "iptables -L OUTPUT"
  key_links:
    - from: ".ddev/docker-compose.firewall.yaml"
      to: ".ddev/firewall/healthcheck.sh"
      via: "healthcheck test command"
      pattern: "healthcheck\\.sh"
    - from: ".ddev/firewall/entrypoint.sh"
      to: "/tmp/ddev-claude-blocked.log"
      via: "logging blocked requests"
      pattern: "ddev-claude-blocked"
---

<objective>
Implement healthcheck validation and internal logging for blocked requests.

Purpose: Ensure the firewall is working correctly (not just that scripts ran) and collect blocked domains for Phase 2's whitelist suggestion feature.

Output: A healthcheck that validates firewall state and internal logging that captures blocked requests without flooding visible logs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-firewall-foundation/01-RESEARCH.md
@.planning/phases/01-firewall-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create healthcheck validation script</name>
  <files>.ddev/firewall/healthcheck.sh</files>
  <action>
Create `.ddev/firewall/healthcheck.sh` to validate firewall is functioning correctly.

**Validation checks (all must pass):**

1. **Verify iptables rules exist:**
   - Check OUTPUT chain has rules loaded
   - Count rules: should be at least 5 (loopback, DNS x2, established, whitelist, log)
   - Fail if too few rules (firewall didn't initialize properly)

2. **Verify OUTPUT policy is DROP:**
   - `iptables -L OUTPUT | head -1` should show `(policy DROP)`
   - If policy is ACCEPT, firewall is not protecting

3. **Verify ipset exists:**
   - `ipset list whitelist_ips` should succeed
   - If ipset doesn't exist, whitelisting won't work

4. **Verify ipset has entries:**
   - Count entries in whitelist_ips
   - Warn (but don't fail) if empty - might be legitimate if no domains configured

5. **Verify blocking works (functional test):**
   - Try to connect to a definitely-blocked IP (e.g., 198.51.100.1 - TEST-NET-2, never routable)
   - Use `timeout 2 nc -zv 198.51.100.1 80 2>&1`
   - If connection succeeds, firewall is NOT blocking - FAIL
   - If connection times out or refused, firewall IS blocking - PASS

**Exit codes:**
- 0: Healthcheck passed, firewall is working
- 1: Healthcheck failed, firewall is broken

**Output format:**
- Log each check with PASS/FAIL
- Final line: "Firewall healthcheck passed" or "Firewall healthcheck FAILED: <reason>"

**Script structure:**
```bash
#!/bin/bash
set -e

LOG_PREFIX="[ddev-claude-healthcheck]"
log() { echo "$LOG_PREFIX $*"; }
fail() { echo "$LOG_PREFIX FAILED: $*" >&2; exit 1; }

# Check 1: iptables rules exist
rule_count=$(iptables -L OUTPUT -n 2>/dev/null | grep -c "^[A-Z]" || echo 0)
if [[ $rule_count -lt 5 ]]; then
  fail "Too few iptables rules ($rule_count), firewall not initialized"
fi
log "PASS: iptables rules loaded ($rule_count rules)"

# Check 2: OUTPUT policy is DROP
policy=$(iptables -L OUTPUT 2>/dev/null | head -1 | grep -o "policy [A-Z]*" || echo "policy UNKNOWN")
if [[ "$policy" != "policy DROP" ]]; then
  fail "OUTPUT policy is not DROP ($policy)"
fi
log "PASS: OUTPUT policy is DROP"

# Check 3: ipset exists
if ! ipset list whitelist_ips &>/dev/null; then
  fail "ipset 'whitelist_ips' not found"
fi
log "PASS: ipset 'whitelist_ips' exists"

# Check 4: ipset has entries (warn only)
entry_count=$(ipset list whitelist_ips 2>/dev/null | grep -c "^[0-9]" || echo 0)
if [[ $entry_count -eq 0 ]]; then
  log "WARN: ipset 'whitelist_ips' is empty (no domains whitelisted)"
else
  log "PASS: ipset has $entry_count IPs whitelisted"
fi

# Check 5: blocking works (functional test)
# Use TEST-NET-2 (198.51.100.0/24) - reserved, never routable
if timeout 2 nc -zv 198.51.100.1 80 2>&1 | grep -q "succeeded\|open"; then
  fail "Firewall not blocking - 198.51.100.1:80 was accessible"
fi
log "PASS: Firewall is blocking non-whitelisted traffic"

log "Firewall healthcheck passed"
exit 0
```
  </action>
  <verify>
Run checks:
```bash
# Script exists and is shell
head -1 .ddev/firewall/healthcheck.sh | grep -q "#!/bin/bash"

# Key validation patterns present
grep -q "iptables -L OUTPUT" .ddev/firewall/healthcheck.sh
grep -q "policy DROP" .ddev/firewall/healthcheck.sh
grep -q "ipset list whitelist_ips" .ddev/firewall/healthcheck.sh
grep -q "timeout" .ddev/firewall/healthcheck.sh
grep -q "exit 0" .ddev/firewall/healthcheck.sh
grep -q "exit 1" .ddev/firewall/healthcheck.sh

# Syntax check
bash -n .ddev/firewall/healthcheck.sh
```
  </verify>
  <done>healthcheck.sh validates iptables rules, DROP policy, ipset existence, and functional blocking test</done>
</task>

<task type="auto">
  <name>Task 2: Add internal logging to entrypoint for blocked requests</name>
  <files>.ddev/firewall/entrypoint.sh</files>
  <action>
Update `.ddev/firewall/entrypoint.sh` to add internal logging for blocked requests (for Phase 2 whitelist suggestions).

**Add a custom NFLOG target** instead of just LOG. This allows us to capture blocked traffic to a file while keeping visible logs rate-limited.

However, NFLOG requires userspace daemon (ulogd2) which adds complexity. Instead, use a simpler approach:

**Simpler approach - use LOG with custom prefix and parse from dmesg:**

The existing LOG rule sends to kernel log (dmesg). We can parse this later. But for Phase 2's whitelist feature, we need a cleaner internal log.

**Best approach for Phase 1:**

1. Keep the existing rate-limited LOG rule for visible logging
2. Add a helper script that can extract blocked IPs from `iptables -L OUTPUT -v -n` (shows packet counts)
3. For Phase 2, we'll add a proper logging mechanism

**For now, add a LOG_BLOCKED_FILE setup:**

1. Create/truncate blocked log file at startup: `> /tmp/ddev-claude-blocked.log`
2. Add a comment noting that Phase 2 will implement proper log parsing
3. The LOG rule already captures to kernel log - Phase 2 can parse dmesg

**Update entrypoint.sh to:**

1. Initialize blocked log file:
   ```bash
   BLOCKED_LOG="/tmp/ddev-claude-blocked.log"
   > "$BLOCKED_LOG"  # Truncate on start (current session only)
   log "Initialized blocked request log at $BLOCKED_LOG"
   ```

2. Update the LOG rule comment to explain Phase 2 will parse it:
   ```bash
   # Log blocked requests (rate limited for visible logs)
   # Phase 2 will parse kernel log for whitelist suggestions
   iptables -A OUTPUT -m limit --limit 2/sec --limit-burst 5 \
     -j LOG --log-prefix "[FIREWALL-BLOCK] " --log-level warning
   ```

3. Add a "how to see blocked requests" message at end:
   ```bash
   log "To see blocked requests: dmesg | grep FIREWALL-BLOCK"
   ```
  </action>
  <verify>
Run checks:
```bash
# Blocked log initialization present
grep -q "BLOCKED_LOG" .ddev/firewall/entrypoint.sh
grep -q "/tmp/ddev-claude-blocked.log" .ddev/firewall/entrypoint.sh

# LOG rule still present with rate limiting
grep -q "limit 2/sec" .ddev/firewall/entrypoint.sh
grep -q "FIREWALL-BLOCK" .ddev/firewall/entrypoint.sh

# Syntax still valid
bash -n .ddev/firewall/entrypoint.sh
```
  </verify>
  <done>entrypoint.sh initializes blocked request log file and includes rate-limited LOG rule with FIREWALL-BLOCK prefix for later parsing</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify healthcheck script:
   ```bash
   # Exists and executable-ready
   test -f .ddev/firewall/healthcheck.sh
   bash -n .ddev/firewall/healthcheck.sh

   # Contains all validation checks
   grep -c "PASS:" .ddev/firewall/healthcheck.sh  # Should be 4-5
   grep -c "fail\|FAILED" .ddev/firewall/healthcheck.sh  # Should be >= 3
   ```

2. Verify entrypoint has logging setup:
   ```bash
   grep -q "BLOCKED_LOG" .ddev/firewall/entrypoint.sh
   grep -q "FIREWALL-BLOCK" .ddev/firewall/entrypoint.sh
   ```

3. Verify docker-compose references healthcheck:
   ```bash
   grep -q "healthcheck.sh" .ddev/docker-compose.firewall.yaml
   ```
</verification>

<success_criteria>
- healthcheck.sh validates: iptables rules loaded, DROP policy set, ipset exists, blocking works
- healthcheck.sh exits 0 on pass, 1 on fail
- entrypoint.sh initializes blocked log file at /tmp/ddev-claude-blocked.log
- entrypoint.sh includes rate-limited LOG rule with FIREWALL-BLOCK prefix
- All scripts pass bash syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/01-firewall-foundation/01-03-SUMMARY.md`
</output>
