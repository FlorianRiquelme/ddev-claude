---
phase: 01-firewall-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - claude/entrypoint.sh
  - claude/resolve-and-apply.sh
  - claude/whitelist-domains.txt
autonomous: true

must_haves:
  truths:
    - "Firewall initializes on container start with default-deny policy"
    - "DNS resolution (port 53) works before DROP policy applies"
    - "Loopback traffic is always allowed"
    - "Established connections receive return traffic"
    - "Whitelisted domains resolve to IPs and are allowed through"
    - "Container stays running after firewall initialization"
  artifacts:
    - path: "claude/entrypoint.sh"
      provides: "Firewall initialization on container start"
      contains: "iptables -P OUTPUT DROP"
    - path: "claude/resolve-and-apply.sh"
      provides: "Domain to IP resolution for whitelist"
      contains: "ipset add"
    - path: "claude/whitelist-domains.txt"
      provides: "Default domain whitelist"
      contains: "api.anthropic.com"
  key_links:
    - from: "claude/entrypoint.sh"
      to: "claude/resolve-and-apply.sh"
      via: "script invocation"
      pattern: "resolve-and-apply\\.sh"
    - from: "claude/entrypoint.sh"
      to: "iptables ipset"
      via: "firewall rule setup"
      pattern: "iptables -A OUTPUT"
    - from: "claude/resolve-and-apply.sh"
      to: "claude/whitelist-domains.txt"
      via: "reads domain list"
      pattern: "whitelist-domains\\.txt"
---

<objective>
Implement the core firewall logic with ENTRYPOINT script, domain resolution, and default whitelist.

Purpose: This is the heart of the firewall - the scripts that initialize iptables rules on container start, resolve whitelisted domains to IPs, and populate the ipset. The rule ordering is critical: DNS must work before DROP policy.

Output: Working firewall that blocks all outbound traffic except whitelisted domains, with proper rule ordering to avoid self-blocking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-firewall-foundation/01-RESEARCH.md
@.planning/phases/01-firewall-foundation/01-CONTEXT.md
@.planning/phases/01-firewall-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create firewall ENTRYPOINT script</name>
  <files>claude/entrypoint.sh</files>
  <action>
Create `claude/entrypoint.sh` with comprehensive firewall initialization.

**Critical rule ordering (top to bottom, in this exact order):**

1. **Setup phase (policy ACCEPT while configuring):**
   - Flush existing OUTPUT rules for idempotency
   - Set OUTPUT policy to ACCEPT temporarily

2. **Create ipset:**
   - `ipset create -exist whitelist_ips hash:ip timeout 3600`
   - Use `-exist` flag for idempotency (no error if already exists)
   - 3600 second timeout (1 hour) - safe default for DNS TTL

3. **Allow loopback (FIRST rule):**
   - `iptables -A OUTPUT -o lo -j ACCEPT`
   - Critical for localhost communication

4. **Allow DNS (BEFORE any restrictions):**
   - `iptables -A OUTPUT -p udp --dport 53 -j ACCEPT`
   - `iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT`
   - Must come before DROP so domain resolution works

5. **Allow established connections:**
   - `iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT`
   - Allows return traffic for connections we initiated

6. **Resolve and populate whitelist:**
   - Call `/var/www/html/.ddev/claude/resolve-and-apply.sh`
   - This resolves domains and adds IPs to ipset

7. **Allow whitelisted IPs:**
   - `iptables -A OUTPUT -m set --match-set whitelist_ips dst -j ACCEPT`
   - Uses ipset for O(1) lookup of whitelisted IPs

8. **Visible logging (rate limited):**
   - `iptables -A OUTPUT -m limit --limit 2/sec --limit-burst 5 -j LOG --log-prefix "[FIREWALL-BLOCK] " --log-level warning`
   - Rate limiting prevents log flooding

9. **Default DROP (LAST):**
   - `iptables -P OUTPUT DROP`
   - Fail closed - anything not explicitly allowed is blocked

10. **Chain to command:**
    - `exec "$@"` at the end
    - Passes through to the command specified in docker-compose

**Error handling:**
- Use `set -euo pipefail` for fail-fast behavior
- Add trap for ERR to log failures
- Log prefix: `[ddev-claude]` for all messages
- If firewall setup fails, container should NOT start (fail closed)

**Script structure:**
```bash
#!/bin/bash
set -euo pipefail

LOG_PREFIX="[ddev-claude]"
SCRIPT_DIR="/var/www/html/.ddev/claude"
WHITELIST_FILE="$SCRIPT_DIR/whitelist-domains.txt"
BLOCKED_LOG="/tmp/ddev-claude-blocked.log"

log() { echo "$LOG_PREFIX $*"; }
error() { echo "$LOG_PREFIX ERROR: $*" >&2; }

# Error trap - fail closed
trap 'error "Firewall initialization failed - blocking all traffic"; exit 1' ERR

log "Initializing firewall rules..."

# Initialize blocked log file (for Phase 2 whitelist suggestions)
> "$BLOCKED_LOG"
log "Initialized blocked request log at $BLOCKED_LOG"

# 1. Flush existing rules (idempotent)
iptables -F OUTPUT 2>/dev/null || true
iptables -P OUTPUT ACCEPT  # Temporarily allow while setting up

# 2. Create ipset (use -exist for idempotency)
ipset create -exist whitelist_ips hash:ip timeout 3600
log "Created ipset 'whitelist_ips'"

# 3. Allow loopback (critical for localhost communication)
iptables -A OUTPUT -o lo -j ACCEPT
log "Allowed loopback interface"

# 4. Allow DNS BEFORE restrictive rules (UDP and TCP)
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
log "Allowed DNS resolution (port 53)"

# 5. Allow established connections (return traffic)
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
log "Allowed established/related connections"

# 6. Resolve domains and populate ipset
if [[ -f "$WHITELIST_FILE" ]]; then
  "$SCRIPT_DIR/resolve-and-apply.sh" "$WHITELIST_FILE"
else
  log "WARNING: Whitelist file not found at $WHITELIST_FILE"
fi

# 7. Allow traffic to whitelisted IPs
iptables -A OUTPUT -m set --match-set whitelist_ips dst -j ACCEPT
log "Allowed whitelisted IPs"

# 8. Log blocked requests (rate limited for visible logs)
# Phase 2 will parse kernel log for whitelist suggestions
iptables -A OUTPUT -m limit --limit 2/sec --limit-burst 5 \
  -j LOG --log-prefix "[FIREWALL-BLOCK] " --log-level warning

# 9. Default DROP (fail closed)
iptables -P OUTPUT DROP
log "Set default policy to DROP"

ip_count=$(ipset list whitelist_ips 2>/dev/null | grep -c "^[0-9]" || echo 0)
log "Firewall initialized successfully ($ip_count IPs whitelisted)"
log "To see blocked requests: dmesg | grep FIREWALL-BLOCK"

# Execute command passed to entrypoint
exec "$@"
```
  </action>
  <verify>
Run checks:
```bash
# Script exists and is shell
head -1 claude/entrypoint.sh | grep -q "#!/bin/bash"

# Critical rule ordering present
grep -n "iptables" claude/entrypoint.sh

# Check key patterns exist in correct order
grep -q "OUTPUT -o lo" claude/entrypoint.sh        # loopback
grep -q "dport 53" claude/entrypoint.sh            # DNS
grep -q "ESTABLISHED,RELATED" claude/entrypoint.sh # conntrack
grep -q "match-set whitelist_ips" claude/entrypoint.sh # ipset match
grep -q "OUTPUT DROP" claude/entrypoint.sh         # default drop
grep -q 'exec "$@"' claude/entrypoint.sh           # chain to command
```
  </verify>
  <done>entrypoint.sh initializes firewall with correct rule ordering: loopback -> DNS -> established -> whitelist -> log -> DROP, and chains to command</done>
</task>

<task type="auto">
  <name>Task 2: Create domain resolution helper script</name>
  <files>claude/resolve-and-apply.sh</files>
  <action>
Create `claude/resolve-and-apply.sh` to resolve domain names and populate ipset.

**Functionality:**

1. Read domains from whitelist file (one per line)
2. Skip empty lines and comments (lines starting with #)
3. For each domain:
   - Resolve to IP addresses using `dig +short A`
   - Use retries: `dig +short +time=2 +tries=3`
   - Handle multiple IPs per domain (CDN, load balancing)
   - Add each IP to ipset with timeout
   - Log: `[ddev-claude] Whitelisted: domain.com -> 1.2.3.4`

4. Error handling:
   - If domain fails to resolve: warn and continue (don't fail entire firewall)
   - Log warning: `[ddev-claude] WARNING: Could not resolve domain.com (skipping)`

5. Summary at end:
   - Log total IPs whitelisted
   - Log any domains that failed to resolve

**Script structure:**
```bash
#!/bin/bash
set -euo pipefail

WHITELIST_FILE="${1:-/var/www/html/.ddev/claude/whitelist-domains.txt}"
LOG_PREFIX="[ddev-claude]"

log() { echo "$LOG_PREFIX $*"; }
warn() { echo "$LOG_PREFIX WARNING: $*" >&2; }

total_ips=0
failed_domains=()

if [[ ! -f "$WHITELIST_FILE" ]]; then
  warn "Whitelist file not found: $WHITELIST_FILE"
  exit 0  # Don't fail - just no domains to whitelist
fi

while IFS= read -r domain || [[ -n "$domain" ]]; do
  # Skip empty lines and comments
  [[ -z "$domain" || "$domain" =~ ^[[:space:]]*# ]] && continue

  # Trim whitespace
  domain=$(echo "$domain" | xargs)

  # Resolve domain with retries
  ips=$(dig +short +time=2 +tries=3 A "$domain" 2>/dev/null | grep -E '^[0-9]+\.' || true)

  if [[ -n "$ips" ]]; then
    while IFS= read -r ip; do
      ipset add -exist whitelist_ips "$ip" timeout 3600
      log "Whitelisted: $domain -> $ip"
      ((total_ips++))
    done <<< "$ips"
  else
    warn "Could not resolve $domain (skipping)"
    failed_domains+=("$domain")
  fi
done < "$WHITELIST_FILE"

log "Whitelist complete: $total_ips IPs added"
if [[ ${#failed_domains[@]} -gt 0 ]]; then
  warn "Failed to resolve: ${failed_domains[*]}"
fi
```
  </action>
  <verify>
Run checks:
```bash
# Script exists and is shell
head -1 claude/resolve-and-apply.sh | grep -q "#!/bin/bash"

# Key patterns present
grep -q "dig +short" claude/resolve-and-apply.sh
grep -q "ipset add" claude/resolve-and-apply.sh
grep -q "timeout 3600" claude/resolve-and-apply.sh
grep -q "whitelist-domains.txt" claude/resolve-and-apply.sh
```
  </verify>
  <done>resolve-and-apply.sh reads whitelist file, resolves domains via dig, adds IPs to ipset with retry logic and graceful error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create default domain whitelist</name>
  <files>claude/whitelist-domains.txt</files>
  <action>
Create `claude/whitelist-domains.txt` with functional defaults for Claude development.

**Include domains for:**

1. **Claude API (required):**
   - api.anthropic.com
   - claude.ai

2. **GitHub (common for development):**
   - github.com
   - api.github.com
   - raw.githubusercontent.com
   - objects.githubusercontent.com
   - codeload.github.com

3. **Package registries:**
   - registry.npmjs.org (npm)
   - packagist.org (Composer)
   - repo.packagist.org (Composer mirror)

4. **Common CDNs for package downloads:**
   - cdn.jsdelivr.net
   - unpkg.com

**Format:**
- One domain per line
- Comments start with #
- Group by category with comment headers

**Example structure:**
```
# Claude API
api.anthropic.com
claude.ai

# GitHub
github.com
api.github.com
raw.githubusercontent.com
objects.githubusercontent.com
codeload.github.com

# Package registries
registry.npmjs.org
packagist.org
repo.packagist.org

# CDNs
cdn.jsdelivr.net
unpkg.com
```

**NOT included (by design per CONTEXT.md):**
- Web search domains (user enables if needed)
- Broad wildcards (we resolve explicit domains)
  </action>
  <verify>
Run checks:
```bash
# File exists
test -f claude/whitelist-domains.txt

# Required domains present
grep -q "api.anthropic.com" claude/whitelist-domains.txt
grep -q "github.com" claude/whitelist-domains.txt
grep -q "registry.npmjs.org" claude/whitelist-domains.txt

# Count domains (non-comment, non-empty lines)
grep -v "^#" claude/whitelist-domains.txt | grep -v "^$" | wc -l
```
  </verify>
  <done>whitelist-domains.txt contains Claude API, GitHub, npm, Composer domains organized by category with comments</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify file structure:
   ```bash
   ls -la claude/
   ```
   Expected: entrypoint.sh, resolve-and-apply.sh, whitelist-domains.txt, Dockerfile.claude, docker-compose.claude.yaml

2. Verify scripts are valid bash:
   ```bash
   bash -n claude/entrypoint.sh
   bash -n claude/resolve-and-apply.sh
   ```

3. Verify critical patterns in entrypoint.sh (in correct order):
   ```bash
   # Get line numbers for key rules
   grep -n "OUTPUT -o lo" claude/entrypoint.sh      # Should be early
   grep -n "dport 53" claude/entrypoint.sh          # Before DROP
   grep -n "OUTPUT DROP" claude/entrypoint.sh       # Should be late
   grep -n 'exec "$@"' claude/entrypoint.sh         # Should be last
   ```

4. Verify whitelist has required domains:
   ```bash
   for domain in api.anthropic.com github.com registry.npmjs.org; do
     grep -q "$domain" claude/whitelist-domains.txt && echo "OK: $domain"
   done
   ```
</verification>

<success_criteria>
- entrypoint.sh exists with correct rule ordering (loopback -> DNS -> established -> whitelist -> DROP)
- entrypoint.sh chains to command with `exec "$@"`
- resolve-and-apply.sh resolves domains and populates ipset with error handling
- whitelist-domains.txt contains Claude API, GitHub, npm, and Composer domains
- All shell scripts pass bash syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/01-firewall-foundation/01-02-SUMMARY.md`
</output>
